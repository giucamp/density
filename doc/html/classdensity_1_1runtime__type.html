<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: runtime_type&lt; COMMON_TYPE, FEATURE_LIST &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classdensity_1_1runtime__type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">runtime_type&lt; COMMON_TYPE, FEATURE_LIST &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="runtime__type_8h_source.html">runtime_type.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa751aeee567f3a896028bc26f5737372"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> = COMMON_TYPE</td></tr>
<tr class="separator:aa751aeee567f3a896028bc26f5737372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02b92af0561444fc7befaeb7d0cebd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ab02b92af0561444fc7befaeb7d0cebd2">feature_list</a> = FEATURE_LIST</td></tr>
<tr class="separator:ab02b92af0561444fc7befaeb7d0cebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae5dbf06252ee10eea586f2360766aa38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ae5dbf06252ee10eea586f2360766aa38">runtime_type</a> () noexcept</td></tr>
<tr class="separator:ae5dbf06252ee10eea586f2360766aa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43b4904cea5fee34853a7000ae854d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ab43b4904cea5fee34853a7000ae854d2">runtime_type</a> (<a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ab43b4904cea5fee34853a7000ae854d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f3349070992accf46cf6cac1e42976"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a55f3349070992accf46cf6cac1e42976">runtime_type</a> (const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a55f3349070992accf46cf6cac1e42976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da20638cee29e15564b55240ef0d2a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a7da20638cee29e15564b55240ef0d2a5">operator=</a> (<a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7da20638cee29e15564b55240ef0d2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1c6f7a4fe5e0951f7c5f1419dd487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a05f1c6f7a4fe5e0951f7c5f1419dd487">operator=</a> (const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a05f1c6f7a4fe5e0951f7c5f1419dd487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a06ed6553409324d6cb4abca7cff53c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a9a06ed6553409324d6cb4abca7cff53c">~runtime_type</a> () noexcept=default</td></tr>
<tr class="separator:a9a06ed6553409324d6cb4abca7cff53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863df8ed6316860117a6bf26e131bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ab863df8ed6316860117a6bf26e131bbd">empty</a> () const  noexcept</td></tr>
<tr class="separator:ab863df8ed6316860117a6bf26e131bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bfacfaaba9195e4498375659f43531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a03bfacfaaba9195e4498375659f43531">clear</a> () noexcept</td></tr>
<tr class="separator:a03bfacfaaba9195e4498375659f43531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44545a936daa510da7f9fe4835f6ee84"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a44545a936daa510da7f9fe4835f6ee84">size</a> () const  noexcept</td></tr>
<tr class="separator:a44545a936daa510da7f9fe4835f6ee84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d2dbaa1c6bb2b299d62e9cc44ceddc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a24d2dbaa1c6bb2b299d62e9cc44ceddc">alignment</a> () const  noexcept</td></tr>
<tr class="separator:a24d2dbaa1c6bb2b299d62e9cc44ceddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aadbec0fcd3f771269379f11c7078b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ae9aadbec0fcd3f771269379f11c7078b">default_construct</a> (void *i_dest) const </td></tr>
<tr class="separator:ae9aadbec0fcd3f771269379f11c7078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7868d62dfc21c9fa4ce2ccad8810caff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a7868d62dfc21c9fa4ce2ccad8810caff">copy_construct</a> (void *i_dest, const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *i_source) const </td></tr>
<tr class="separator:a7868d62dfc21c9fa4ce2ccad8810caff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dae21b8142a2d5f0c70b15f48ff8d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a3dae21b8142a2d5f0c70b15f48ff8d16">move_construct</a> (void *i_dest, <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *i_source) const </td></tr>
<tr class="separator:a3dae21b8142a2d5f0c70b15f48ff8d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364d39f4d71e5bb486ab83db8bd6876d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a364d39f4d71e5bb486ab83db8bd6876d">destroy</a> (<a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *i_dest) const  noexcept</td></tr>
<tr class="separator:a364d39f4d71e5bb486ab83db8bd6876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e306e798ad223d6d2b481bbb8cdb432"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a8e306e798ad223d6d2b481bbb8cdb432">type_info</a> () const  noexcept</td></tr>
<tr class="separator:a8e306e798ad223d6d2b481bbb8cdb432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172361ca1d8d5af7a5020e09ab4ec7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a0172361ca1d8d5af7a5020e09ab4ec7d">are_equal</a> (const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *i_first, const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *i_second) const </td></tr>
<tr class="separator:a0172361ca1d8d5af7a5020e09ab4ec7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be97fc2b24c0b746dbcd655948a32d"><td class="memTemplParams" colspan="2">template&lt;typename FEATURE &gt; </td></tr>
<tr class="memitem:a20be97fc2b24c0b746dbcd655948a32d"><td class="memTemplItemLeft" align="right" valign="top">FEATURE::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a20be97fc2b24c0b746dbcd655948a32d">get_feature</a> () const  noexcept</td></tr>
<tr class="separator:a20be97fc2b24c0b746dbcd655948a32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872ae71ef3a6ae9f0acb0f99a5a3a180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a872ae71ef3a6ae9f0acb0f99a5a3a180">operator==</a> (const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;i_other) const  noexcept</td></tr>
<tr class="separator:a872ae71ef3a6ae9f0acb0f99a5a3a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6cfd416cf9b900b2fce82881e10018"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a8e6cfd416cf9b900b2fce82881e10018">operator!=</a> (const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> &amp;i_other) const  noexcept</td></tr>
<tr class="separator:a8e6cfd416cf9b900b2fce82881e10018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7420a5e28322c9a7a3348d35b46fbe66"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a7420a5e28322c9a7a3348d35b46fbe66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a7420a5e28322c9a7a3348d35b46fbe66">is</a> () const  noexcept</td></tr>
<tr class="separator:a7420a5e28322c9a7a3348d35b46fbe66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adeb0b1bf92a27fd77db62aa2a79e17"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#a0adeb0b1bf92a27fd77db62aa2a79e17">hash</a> () const  noexcept</td></tr>
<tr class="separator:a0adeb0b1bf92a27fd77db62aa2a79e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab886d51d6e9787a4a9eee9455e024e01"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ab886d51d6e9787a4a9eee9455e024e01"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">make</a> () noexcept</td></tr>
<tr class="separator:ab886d51d6e9787a4a9eee9455e024e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename COMMON_TYPE = void, typename FEATURE_LIST = typename type_features::default_type_features_t&lt;COMMON_TYPE&gt;&gt;<br />
class density::runtime_type&lt; COMMON_TYPE, FEATURE_LIST &gt;</h3>

<p>Class template that performs type-erasure. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMMON_TYPE</td><td>Type to which all type-erased types are covariant. If it is void, any type can be type-erased. </td></tr>
    <tr><td class="paramname">FEATURE_LIST</td><td>Type_features::feature_list that defines which type-features are type-erased. By default the feature_list is obtained with <a class="el" href="structdensity_1_1type__features_1_1default__type__features.html">type_features::default_type_features</a>. If this type is not a <a class="el" href="structdensity_1_1type__features_1_1feature__list.html">type_features::feature_list</a>, a compile time error is reported.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> meets the requirements of <a class="el" href="RuntimeType_concept.html">RuntimeType</a>.</p>
<p>An instance of <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> binds at runtime to a target type. It can be used to construct, copy-construct, destroy, etc., instances of the target types, depending on the features included on <code>FEATURE_LIST</code>. <br />
A <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> bound to a type can be created with the static function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>. <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> has value semantic, and is copyable. <br />
A default-constructed <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> is empty: trying to use type-features of an empty <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> leads to undefined behavior. A <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> becomes empty is the member function <a class="el" href="classdensity_1_1runtime__type.html#a03bfacfaaba9195e4498375659f43531">clear</a> is called.</p>
<p><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> exposes a set of functions to manipulate instances of the target type. Furthermore it can be extended with any type feature built-in in density (for example <a class="el" href="structdensity_1_1type__features_1_1equals.html">type_features::equals</a> or <a class="el" href="structdensity_1_1type__features_1_1less.html">type_features::less</a>). User-defined features are also supported, to add custom capabilities to the type erasure (see the examples below). <br />
Features can be queried with the function <a class="el" href="classdensity_1_1runtime__type.html#a20be97fc2b24c0b746dbcd655948a32d">runtime_type::get_feature</a>, specifying the requested feature at compile-time as template argument. The search is performed at compile time. If the requested feature is not included in <code>FEATURE_LIST</code>, a static_assert fails.</p>
<p><br />
<b>Implementation</b> <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> is implemented as a pointer to a pseudo vtable, that is a static array of feature values: for every feature in FEATURE_LIST there is an entry in this vtable. Most entries are pointer to functions. Anyway, some features (notably <a class="el" href="structdensity_1_1type__features_1_1size.html">type_features::size</a> and <a class="el" href="structdensity_1_1type__features_1_1alignment.html">type_features::alignment</a>) store a static const value.</p>
<p>In this example an <code>std::string</code> is created and destroyed using a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> MyRTType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size&gt; &gt;;</div><div class="line"></div><div class="line">    MyRTType type = MyRTType::make&lt;std::string&gt;();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> * buff = malloc(type.size());</div><div class="line"></div><div class="line">    type.default_construct(buff);</div><div class="line"></div><div class="line">    <span class="comment">// now buff points to a valid std::string</span></div><div class="line">    *<span class="keyword">static_cast&lt;</span>std::string*<span class="keyword">&gt;</span>(buff) = <span class="stringliteral">&quot;hello world!&quot;</span>;</div><div class="line"></div><div class="line">    type.destroy(buff);</div><div class="line"></div><div class="line">    free(buff);</div><div class="line"></div></div><!-- fragment --><p> This is an example of user-defined features: it calls a function named <code>update</code>, that takes as parameter a <code>float</code>.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* This feature calls an update function on any object. The update has not to be virtual, as</span></div><div class="line"><span class="comment">        type erasure already is a kind of virtualization. */</span></div><div class="line">    <span class="keyword">struct </span>feature_call_update</div><div class="line">    {</div><div class="line">        <span class="keyword">using</span> type = void(*)(<span class="keywordtype">void</span> * i_dest, <span class="keywordtype">float</span> i_elapsed_time);</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BASE, <span class="keyword">typename</span> TYPE&gt; <span class="keyword">struct </span>Impl</div><div class="line">        {</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> invoke(<span class="keywordtype">void</span> * i_base_dest, <span class="keywordtype">float</span> i_elapsed_time) noexcept</div><div class="line">            {</div><div class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> base_dest = <span class="keyword">static_cast&lt;</span>BASE*<span class="keyword">&gt;</span>(i_base_dest);</div><div class="line">                <span class="keyword">static_cast&lt;</span>TYPE*<span class="keyword">&gt;</span>(base_dest)-&gt;update(i_elapsed_time);</div><div class="line">            }</div><div class="line">            <span class="keyword">static</span> <span class="keyword">const</span> uintptr_t value;</div><div class="line">        };</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TYPE, <span class="keyword">typename</span> BASE&gt;</div><div class="line">        <span class="keyword">const</span> uintptr_t feature_call_update::Impl&lt;TYPE, BASE&gt;::value = <span class="keyword">reinterpret_cast&lt;</span>uintptr_t<span class="keyword">&gt;</span>(invoke);</div><div class="line"></div></div><!-- fragment --><p> The example below uses feature_call_update. Note that:</p><ul>
<li><code>ObjectA</code> and <code>ObjectB</code> are unrelated types (no common base class)</li>
<li><code>ObjectA::update</code> and <code>ObjectB::update</code> are not virtual functions</li>
<li>If a <code>std::string</code> was added to the array, a compile time error would report that <code>std::string</code> has not an update function</li>
</ul>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">struct </span>ObjectA</div><div class="line">    {</div><div class="line">        <span class="keywordtype">void</span> update(<span class="keywordtype">float</span> i_elapsed_time)</div><div class="line">            { std::cout &lt;&lt; <span class="stringliteral">&quot;ObjectA::update(&quot;</span> &lt;&lt; i_elapsed_time &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl; }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">struct </span>ObjectB</div><div class="line">    {</div><div class="line">        <span class="keywordtype">void</span> update(<span class="keywordtype">float</span> i_elapsed_time)</div><div class="line">            { std::cout &lt;&lt; <span class="stringliteral">&quot;ObjectB::update(&quot;</span> &lt;&lt; i_elapsed_time &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl; }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line"></div><div class="line">    <span class="comment">// concatenates feature_call_update to the default features (destroy, size, alignment)</span></div><div class="line">    <span class="keyword">using</span> MyFeatures = feature_concat_t&lt;default_type_features_t&lt;void&gt;, feature_call_update&gt;;</div><div class="line"></div><div class="line">    <span class="comment">// create a queue with 3 objects</span></div><div class="line">    heter_queue&lt;void, runtime_type&lt;void, MyFeatures&gt;, void_allocator &gt; my_queue;</div><div class="line">    my_queue.emplace&lt;ObjectA&gt;();</div><div class="line">    my_queue.emplace&lt;ObjectB&gt;();</div><div class="line">    my_queue.emplace&lt;ObjectB&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// call update on all the objects</span></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> end_it = my_queue.end();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = my_queue.begin(); it != end_it; ++it)</div><div class="line">    {</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> update_func = it-&gt;first.get_feature&lt;feature_call_update&gt;();</div><div class="line">        update_func(it-&gt;second, 1.f / 60.f );</div><div class="line">    }</div></div><!-- fragment --><p> Output:</p>
<div class="fragment"><div class="line">ObjectA::update(0.0166667)</div><div class="line">ObjectB::update(0.0166667)</div><div class="line">ObjectB::update(0.0166667)</div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa751aeee567f3a896028bc26f5737372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> =  COMMON_TYPE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the template argument COMMON_TYPE </p>

</div>
</div>
<a class="anchor" id="ab02b92af0561444fc7befaeb7d0cebd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1runtime__type.html#ab02b92af0561444fc7befaeb7d0cebd2">feature_list</a> =  FEATURE_LIST</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the template argument FEATURE_LIST </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae5dbf06252ee10eea586f2360766aa38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an empty <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> not associated with any type. Trying to use any feature of an empty <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> leads to undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ab43b4904cea5fee34853a7000ae854d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move-constructs a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </p>

</div>
</div>
<a class="anchor" id="a55f3349070992accf46cf6cac1e42976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy-constructs a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </p>

</div>
</div>
<a class="anchor" id="a9a06ed6553409324d6cb4abca7cff53c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab886d51d6e9787a4a9eee9455e024e01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> make </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> associated with the specified type. The latter is the target type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>target type that is type-erased by the returned <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7da20638cee29e15564b55240ef0d2a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move-assigns a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. Self assignment (a = a) is not supported, and leads to undefined behavior. </p>

</div>
</div>
<a class="anchor" id="a05f1c6f7a4fe5e0951f7c5f1419dd487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy-assigns a <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. Self assignment (a = a) is not supported, and leads to undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ab863df8ed6316860117a6bf26e131bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> is not bound to a target type </p>

</div>
</div>
<a class="anchor" id="a03bfacfaaba9195e4498375659f43531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unbind from a target. If the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> was already empty this function has no effect. </p>

</div>
</div>
<a class="anchor" id="a44545a936daa510da7f9fe4835f6ee84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size (in bytes) of the target type, which is always &gt; 0. <br />
The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">sizeof</span>(TARGET_TYPE);</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>).</p>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1size.html">type_features::size</a> must be included in the FEATURE_LIST <br />
</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> nothing </p>

</div>
</div>
<a class="anchor" id="a24d2dbaa1c6bb2b299d62e9cc44ceddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t alignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the alignment (in bytes) of the target type, which is always an integer power of 2. <br />
 The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">alignof</span>(TARGET_TYPE);</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>).</p>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1alignment.html">type_features::alignment</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> nothing </p>

</div>
</div>
<a class="anchor" id="ae9aadbec0fcd3f771269379f11c7078b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>* default_construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructs an instance of the target type on the specified uninitialized storage. <br />
The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>*<span class="keyword">&gt;</span>( <span class="keyword">new</span>(i_dest) TARGET_TYPE() );</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>). Note that primitive types are initialized by this expression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_dest</td><td>pointer to a buffer in which the target type is inplace constructed. This buffer must be large at least as the result of <a class="el" href="classdensity_1_1runtime__type.html#a44545a936daa510da7f9fe4835f6ee84">runtime_type::size</a>, and must be aligned at least according to <a class="el" href="classdensity_1_1runtime__type.html#a24d2dbaa1c6bb2b299d62e9cc44ceddc">runtime_type::alignment</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the common_type subobject of the instance of TARGET_TYPE that has been constructed. Note: do not assume that the value of this pointer is the same of i_dest.</dd></dl>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1default__construct.html">type_features::default_construct</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> anything that the default constructor of the target type throws. </p>

</div>
</div>
<a class="anchor" id="a7868d62dfc21c9fa4ce2ccad8810caff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>* copy_construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructs an instance of the target type on the specified uninitialized storage. <br />
The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>*<span class="keyword">&gt;</span>( <span class="keyword">new</span>(i_dest) TARGET_TYPE(</div><div class="line">    *dynamic_cast&lt;const TARGET_TYPE*&gt;(i_source) ) );</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>). <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_dest</td><td>pointer to a buffer in which the target type is inplace constructed. This buffer must be large at least as the result of <a class="el" href="classdensity_1_1runtime__type.html#a44545a936daa510da7f9fe4835f6ee84">runtime_type::size</a>, and must be aligned at least according to <a class="el" href="classdensity_1_1runtime__type.html#a24d2dbaa1c6bb2b299d62e9cc44ceddc">runtime_type::alignment</a>. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to a subobject common_type of an instance of TARGET_TYPE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the common_type subobject of the instance of TARGET_TYPE that has been constructed. Note: do not assume that the value of this pointer is the same of i_dest.</dd></dl>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1copy__construct.html">type_features::copy_construct</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> anything that the copy constructor of the target type throws. </p>

</div>
</div>
<a class="anchor" id="a3dae21b8142a2d5f0c70b15f48ff8d16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>* move_construct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructs an instance of the target type on the specified uninitialized storage. <br />
The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a>*<span class="keyword">&gt;</span>( <span class="keyword">new</span>(i_dest) TARGET_TYPE(</div><div class="line">    std::move(*dynamic_cast&lt;TARGET_TYPE*&gt;(i_source)) ) );</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>). <br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_dest</td><td>pointer to a buffer in which the target type is inplace constructed. This buffer must be large at least as the result of <a class="el" href="classdensity_1_1runtime__type.html#a44545a936daa510da7f9fe4835f6ee84">runtime_type::size</a>, and must be aligned at least according to <a class="el" href="classdensity_1_1runtime__type.html#a24d2dbaa1c6bb2b299d62e9cc44ceddc">runtime_type::alignment</a>. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to a subobject common_type of an instance of TARGET_TYPE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the common_type subobject of the instance of TARGET_TYPE that has been constructed. Note: do not assume that the value of this pointer is the same of i_dest.</dd></dl>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1move__construct.html">type_features::move_construct</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty </li>
</ul>

</div>
</div>
<a class="anchor" id="a364d39f4d71e5bb486ab83db8bd6876d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td>
          <td class="paramname"><em>i_dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys an object of the target type through a pointer to the subobject common_type.</p>
<p>The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keyword">dynamic_cast&lt;</span>TARGET_TYPE*<span class="keyword">&gt;</span>(i_source)-&gt;~TARGET_TYPE::TARGET_TYPE();</div><div class="line"><span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>TARGET_TYPE*<span class="keyword">&gt;</span>(i_source);</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>). <br />
 </p><dl class="section return"><dt>Returns</dt><dd>pointer to the complete object that has been destroyed. This pointer can be used to deallocate a memory block on the heap.</dd></dl>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1destroy.html">type_features::destroy</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> nothing. Destructors are required to be noexcept. </p>

</div>
</div>
<a class="anchor" id="a8e306e798ad223d6d2b481bbb8cdb432"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; type_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the std::type_info associated to the target type.</p>
<p>The effect of this function is the same of this code: </p><div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="keyword">typeid</span>(TARGET_TYPE);</div></div><!-- fragment --><p> where TARGET_TYPE is the target type (see the static member function <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make</a>). <br />
 <br />
<b>Requires:</b> </p><ul>
<li>the feature <a class="el" href="structdensity_1_1type__features_1_1rtti.html">type_features::rtti</a> must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> nothing. </p>

</div>
</div>
<a class="anchor" id="a0172361ca1d8d5af7a5020e09ab4ec7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool are_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html#aa751aeee567f3a896028bc26f5737372">common_type</a> *&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if two instances of the target types compare equal. <br />
<b>Throws:</b> unspecified </p>

</div>
</div>
<a class="anchor" id="a20be97fc2b24c0b746dbcd655948a32d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FEATURE::type get_feature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the feature matching the specified type, if present. If the feature is not present, a static_assert fails. This function grant access to features that are not part of the interface of <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>.</p>
<p>The search a the feature is done at compile time, so the complexity is alway constant.</p>
<p><br />
<b>Requires:</b> </p><ul>
<li>the feature FEATURE must be included in the FEATURE_LIST</li>
<li>the <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> must be non-empty</li>
</ul>
<p><br />
<b>Throws:</b> nothing. </p>

</div>
</div>
<a class="anchor" id="a872ae71ef3a6ae9f0acb0f99a5a3a180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true whether this two <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> have the same target type. All empty <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>'s compare equals.</p>
<p><br />
<b>Requires:</b> nothing</p>
<p><br />
<b>Throws:</b> nothing. </p>

</div>
</div>
<a class="anchor" id="a8e6cfd416cf9b900b2fce82881e10018"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>&lt; COMMON_TYPE, FEATURE_LIST &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true whether this two <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> have different target types. All empty <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>'s compare equals.</p>
<p><br />
<b>Requires:</b> nothing</p>
<p><br />
<b>Throws:</b> nothing. </p>

</div>
</div>
<a class="anchor" id="a7420a5e28322c9a7a3348d35b46fbe66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the target type of this <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> is exactly the one specified in the template parameter. Equivalent to *this == <a class="el" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type::make&lt;TYPE&gt;()</a> </p>

</div>
</div>
<a class="anchor" id="a0adeb0b1bf92a27fd77db62aa2a79e17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an hash. This function is used for the partial specialization of std::hash for <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="runtime__type_8h_source.html">runtime_type.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
