<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: conc_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdensity_1_1conc__heter__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">conc_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="conc__heter__queue_8h_source.html">conc_heter_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa751aeee567f3a896028bc26f5737372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa751aeee567f3a896028bc26f5737372"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>common_type</b> = COMMON_TYPE</td></tr>
<tr class="separator:aa751aeee567f3a896028bc26f5737372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b50f4f25fd3da4205169b7280303e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad98b50f4f25fd3da4205169b7280303e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_type</b> = RUNTIME_TYPE</td></tr>
<tr class="separator:ad98b50f4f25fd3da4205169b7280303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9253fca0e3b116143a118d211fb39002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9253fca0e3b116143a118d211fb39002"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt; const runtime_type &amp;, common_type *const  &gt;</td></tr>
<tr class="separator:a9253fca0e3b116143a118d211fb39002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bafeb4e974cce856d533d2bb3de432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8bafeb4e974cce856d533d2bb3de432"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = ALLOCATOR_TYPE</td></tr>
<tr class="separator:ad8bafeb4e974cce856d533d2bb3de432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc03915d7633dfe3c2b7a160f410549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc03915d7633dfe3c2b7a160f410549"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:a6fc03915d7633dfe3c2b7a160f410549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce9d8c8e35f6c6ffb564c2e733ea05e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const value_type *</td></tr>
<tr class="separator:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22bd40cacb993e9bf49cf10e7ef245a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type</td></tr>
<tr class="separator:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1137da269e66589b98fce3416d40502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1137da269e66589b98fce3416d40502"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:ab1137da269e66589b98fce3416d40502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ce1af42d538f410180c265518d4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af38ce1af42d538f410180c265518d4f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:af38ce1af42d538f410180c265518d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace405568d0b2f3fad4990044252c7732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace405568d0b2f3fad4990044252c7732"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="separator:ace405568d0b2f3fad4990044252c7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab5cb0469e5b574b65e39d805b11cf098"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ab5cb0469e5b574b65e39d805b11cf098">conc_heter_queue</a> () noexcept=default</td></tr>
<tr class="separator:ab5cb0469e5b574b65e39d805b11cf098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97561622802cc9c71879267228d84b3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a97561622802cc9c71879267228d84b3f">conc_heter_queue</a> (const ALLOCATOR_TYPE &amp;i_source_allocator) noexcept(std::is_nothrow_copy_constructible&lt; ALLOCATOR_TYPE &gt;::value)</td></tr>
<tr class="separator:a97561622802cc9c71879267228d84b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99820daa0dd63262e30528daea1aad82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a99820daa0dd63262e30528daea1aad82">conc_heter_queue</a> (ALLOCATOR_TYPE &amp;&amp;i_source_allocator) noexcept(std::is_nothrow_move_constructible&lt; ALLOCATOR_TYPE &gt;::value)</td></tr>
<tr class="separator:a99820daa0dd63262e30528daea1aad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d12bab9678728c5bdefc615c7629a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ad6d12bab9678728c5bdefc615c7629a4">conc_heter_queue</a> (<a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:ad6d12bab9678728c5bdefc615c7629a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d54a5477a324852296a444a4aef990"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ab2d54a5477a324852296a444a4aef990">operator=</a> (<a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:ab2d54a5477a324852296a444a4aef990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ac29f19b7f4021ce4a40e84ab895ab453">get_allocator</a> () noexcept(std::is_nothrow_copy_constructible&lt; allocator_type &gt;::value)</td></tr>
<tr class="separator:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6418bf0426ef570443a93d4456fa523"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ab6418bf0426ef570443a93d4456fa523">get_allocator_ref</a> () noexcept</td></tr>
<tr class="separator:ab6418bf0426ef570443a93d4456fa523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memItemLeft" align="right" valign="top">const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a15eaf0df4f1d8976f3e799f796dc6f7c">get_allocator_ref</a> () const  noexcept</td></tr>
<tr class="separator:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab469e36ad7836ce4c3ca181ad4cbd252"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ab469e36ad7836ce4c3ca181ad4cbd252">~conc_heter_queue</a> ()=default</td></tr>
<tr class="separator:ab469e36ad7836ce4c3ca181ad4cbd252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863df8ed6316860117a6bf26e131bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ab863df8ed6316860117a6bf26e131bbd">empty</a> () const  noexcept</td></tr>
<tr class="separator:ab863df8ed6316860117a6bf26e131bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bfacfaaba9195e4498375659f43531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a03bfacfaaba9195e4498375659f43531">clear</a> () noexcept</td></tr>
<tr class="separator:a03bfacfaaba9195e4498375659f43531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94888fab06d0078cd93ac1562fcce9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a94888fab06d0078cd93ac1562fcce9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867536308877c33bfb29f5ca8c9ebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a52867536308877c33bfb29f5ca8c9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da90ba09177e403d9bd6f466d332eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a8da90ba09177e403d9bd6f466d332eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a857a56adb973d294e1cf85acca8efbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a722ecea4d64dc7853d3825f24f316b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65085a9e9c299f23ad95b297752d3775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a65085a9e9c299f23ad95b297752d3775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">start_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194977988482bd3bcfeb92c14ccef60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">start_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a194977988482bd3bcfeb92c14ccef60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274dca2a1d2c68ff3249f37b3ae410d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a274dca2a1d2c68ff3249f37b3ae410d5">pop</a> () noexcept</td></tr>
<tr class="separator:a274dca2a1d2c68ff3249f37b3ae410d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a35b9c85fad7f5d27b7555c29b2e4e3fe">try_pop</a> () noexcept</td></tr>
<tr class="separator:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1ab782b6edf567268eee5613c82d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume</a> () noexcept</td></tr>
<tr class="separator:ac6f1ab782b6edf567268eee5613c82d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b75e28b72dcb69afe98280ad561e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a616b75e28b72dcb69afe98280ad561e0">try_start_consume</a> (<a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:a616b75e28b72dcb69afe98280ad561e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#abd4493f55adeab87efb382c118066a2e">reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:abd4493f55adeab87efb382c118066a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a0faba214d7f09f7af2d8ee795490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a22a0faba214d7f09f7af2d8ee795490d">reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a22a0faba214d7f09f7af2d8ee795490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a09fc9a353af5e0de17d9cd2c74876c3f">reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a4f42d9c13317c6a1412686c42609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a711a4f42d9c13317c6a1412686c42609">reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a711a4f42d9c13317c6a1412686c42609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a43e3c73b2740ce46477422fb90d18208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a6aa035e6311be7c63c72334427572193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d63c59edac31a0d50efc67bdd9381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a298d63c59edac31a0d50efc67bdd9381">start_reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a298d63c59edac31a0d50efc67bdd9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55249c74018c4dad488fb1eebec8bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a55249c74018c4dad488fb1eebec8bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6abd47f0a85b6d2f90de584c05270c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#af6abd47f0a85b6d2f90de584c05270c0">start_reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:af6abd47f0a85b6d2f90de584c05270c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83c43fd2aca56043d4209f67dd579a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#aa83c43fd2aca56043d4209f67dd579a1">reentrant_pop</a> () noexcept</td></tr>
<tr class="separator:aa83c43fd2aca56043d4209f67dd579a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#ac83d6e59ab5dec61205db0cea6e6cf5b">try_reentrant_pop</a> () noexcept</td></tr>
<tr class="separator:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume</a> () noexcept</td></tr>
<tr class="separator:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#aab0a2b3d02d22ceb03b4bf8efdf13d47">try_start_reentrant_consume</a> (<a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a58697d487018a8bde47d4c274c7bd76a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a58697d487018a8bde47d4c274c7bd76a">concurrent_puts</a> = true</td></tr>
<tr class="separator:a58697d487018a8bde47d4c274c7bd76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a2e2bd4f332d922d3024a4bb65f9d17e4">concurrent_consumes</a> = true</td></tr>
<tr class="separator:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30744c14b0233cd7f55466ff04151aa9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a30744c14b0233cd7f55466ff04151aa9">concurrent_put_consumes</a> = true</td></tr>
<tr class="separator:a30744c14b0233cd7f55466ff04151aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7708a88b67261ef454d875047bcfa79d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a7708a88b67261ef454d875047bcfa79d">is_seq_cst</a> = true</td></tr>
<tr class="separator:a7708a88b67261ef454d875047bcfa79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#a2cdcdcfbd2342ad05b1c907bfaf76703">min_alignment</a> = InnerQueue::min_alignment</td></tr>
<tr class="separator:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abb8fbaa4b1d68aaea3b603a10e39836e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1conc__heter__queue.html#abb8fbaa4b1d68aaea3b603a10e39836e">swap</a> (<a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;i_first, <a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;i_second) noexcept</td></tr>
<tr class="separator:abb8fbaa4b1d68aaea3b603a10e39836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename COMMON_TYPE = void, typename RUNTIME_TYPE = runtime_type&lt;COMMON_TYPE&gt;, typename ALLOCATOR_TYPE = void_allocator&gt;<br />
class density::conc_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt;</h3>

<p>Class template implementing a concurrent heterogeneous FIFO pseudo-container.</p>
<p><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> is a concurrent version of <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>, with a mutex embedded within. It allows different threads to put and consume elements concurrently without any external synchronization.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMMON_TYPE</td><td>Common type of all the elements. An object of type E can be pushed on the queue only if E* is implicitly convertible to COMMON_TYPE*. If COMMON_TYPE is void (the default), any type can be put in the queue. Otherwise it should be an user-defined-type, and only types deriving from it can be added. </td></tr>
    <tr><td class="paramname">RUNTIME_TYPE</td><td>Runtime-type object used to handle the actual complete type of each element. This type must meet the requirements of <a class="el" href="RuntimeType_concept.html">RuntimeType</a>. The default is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. </td></tr>
    <tr><td class="paramname">ALLOCATOR_TYPE</td><td>Allocator type to be used. This type must meet the requirements of both <a class="el" href="UntypedAllocator_concept.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_concept.html">PagedAllocator</a>. The default is <a class="el" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">density::void_allocator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Thread safeness</b>: Put and consumes can be executed concurrently. Lifetime function can't. <br />
 <b>Exception safeness</b>: Any function of <a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> is noexcept or provides the strong exception guarantee.</p>
<h2>Implementation and performance notes </h2>
<p><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> is basically an <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> protected by an std::mutex to avoid data races.</p>
<p>Non-reentrant operations keep the mutex locked during the whole operation (until the operation is canceled or commited). Reentrant operations minimize the durations of the locks: the mutex is locked once when the operation starts, and another time to commit or cancel the operation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab5cb0469e5b574b65e39d805b11cf098"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. The allocator is default-constructed.</p>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory and never throws.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97561622802cc9c71879267228d84b3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is copy-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to copy-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: whatever the copy constructor of the allocator throws. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the copy constructor of the allocator throws.</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a> allocator;</div><div class="line">    conc_heter_queue&lt;&gt; queue(allocator);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99820daa0dd63262e30528daea1aad82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is move-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to move-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: whatever the move constructor of the allocator throws. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the move constructor of the allocator throws.</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a> allocator;</div><div class="line">    conc_heter_queue&lt;&gt; queue(std::move(allocator));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad6d12bab9678728c5bdefc615c7629a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. The allocator is move-constructed from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue_1(std::move(queue));</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line">    assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab469e36ad7836ce4c3ca181ad4cbd252"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator pointing to this queue is invalidated. <br />
 <b>Throws</b>: Nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab2d54a5477a324852296a444a4aef990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment. The allocator is move-assigned from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: Any iterator pointing to this queue or to the source queue is invalidated. <br />
 <b>Throws</b>: Nothing.</p>
<p><br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
<li>The complexity is linear in the number of elements in this queue.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue_1;</div><div class="line">    queue_1 = std::move(queue);</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line"></div><div class="line">    assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac29f19b7f4021ce4a40e84ab895ab453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the allocator</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.get_allocator() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6418bf0426ef570443a93d4456fa523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the allocator</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15eaf0df4f1d8976f3e799f796dc6f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the allocator</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> &amp; queue_ref = queue;</div><div class="line">    assert(queue_ref.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab863df8ed6316860117a6bf26e131bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the queue contains no elements.</p>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.empty());</div><div class="line">    queue.push(1);</div><div class="line">    assert(!queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03bfacfaaba9195e4498375659f43531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all the elements in the queue.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator is invalidated <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.clear();</div><div class="line">    assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae79645ce0f8c0616bbfda669fa6fbadf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed</li>
<li>If this argument is an r-value, the new element move-constructed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.push(12);</div><div class="line">    queue.push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a49d0820906b9bd4c1b5a1b08980a9330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument ELEMENT_TYPE can't be deduced from the parameters so it must explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.emplace&lt;<span class="keywordtype">int</span>&gt;();</div><div class="line">    queue.emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a94888fab06d0078cd93ac1562fcce9bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, default-constructing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::default_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>default_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    queue.dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a52867536308877c33bfb29f5ca8c9ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of a type known at runtime, copy-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code>. <em>Note</em>: be careful using void pointers: only the compiler knows how to casts from/to a base to/from a derived class.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::copy_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>copy_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8da90ba09177e403d9bd6f466d332eca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code> <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::move_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>move_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857a56adb973d294e1cf85acca8efbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed.</li>
<li>If this argument is an r-value, the new element move-constructed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_push(12);</div><div class="line">    put.element() += 2;</div><div class="line">    put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a722ecea4d64dc7853d3825f24f316b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;ELEMENT_TYPE&gt; start_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">    put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">    put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65085a9e9c299f23ad95b297752d3775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, default-constructing it. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push(type);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aac2746c80dae973ad196b7f12c1bbcc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, copy-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push_copy(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a194977988482bd3bcfeb92c14ccef60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, move-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push_move(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a274dca2a1d2c68ff3249f37b3ae410d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<p>This function is equivalent to:</p>
<p><code><a class="el" href="classdensity_1_1conc__heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume()</a>.commit(); </code></p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if the queue is empty.</dd></dl>
<p><b>Complexity</b>: constant <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    queue.pop();</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a35b9c85fad7f5d27b7555c29b2e4e3fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> pop_result = queue.try_pop();</div><div class="line">    assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    pop_result = queue.try_pop();</div><div class="line">    assert(pop_result == <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6f1ab782b6edf567268eee5613c82d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> try_start_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_1 = queue.try_start_consume();</div><div class="line">    assert(!consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_2 = queue.try_start_consume();</div><div class="line">    assert(consume_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a616b75e28b72dcb69afe98280ad561e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a>. For an <a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> there is no performance difference between the two overloads. Anyway for lock-free concurrent queue this overload may be faster.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    conc_heter_queue&lt;&gt;::consume_operation consume_1;</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_consume(consume_1);</div><div class="line">    assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    conc_heter_queue&lt;&gt;::consume_operation consume_2;</div><div class="line">    <span class="keyword">auto</span> bool_2 = queue.try_start_consume(consume_2);</div><div class="line">    assert(consume_2 &amp;&amp; bool_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd4493f55adeab87efb382c118066a2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">conc_heter_queue::push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.reentrant_push(12);</div><div class="line">    queue.reentrant_push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99a0cef94c1cde53cf68ce8c11bbc74f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">conc_heter_queue::emplace</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.reentrant_emplace&lt;<span class="keywordtype">int</span>&gt;();</div><div class="line">    queue.reentrant_emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a22a0faba214d7f09f7af2d8ee795490d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">conc_heter_queue::dyn_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    queue.reentrant_dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a09fc9a353af5e0de17d9cd2c74876c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">conc_heter_queue::dyn_push_copy</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.reentrant_dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a711a4f42d9c13317c6a1412686c42609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">conc_heter_queue::dyn_push_move</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.reentrant_dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a43e3c73b2740ce46477422fb90d18208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">conc_heter_queue::start_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_push(12);</div><div class="line">    put.element() += 2;</div><div class="line">    put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6aa035e6311be7c63c72334427572193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">conc_heter_queue::start_emplace</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">    put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">    put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a298d63c59edac31a0d50efc67bdd9381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a65085a9e9c299f23ad95b297752d3775">conc_heter_queue::start_dyn_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push(type);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a55249c74018c4dad488fb1eebec8bde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">conc_heter_queue::start_dyn_push_copy</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_copy(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6abd47f0a85b6d2f90de584c05270c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1conc__heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">conc_heter_queue::start_dyn_push_move</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    conc_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_move(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa83c43fd2aca56043d4209f67dd579a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue. This is the reentrant version of pop. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<p>This function is equivalent to:</p>
<p><code><a class="el" href="classdensity_1_1conc__heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume()</a>.commit(); </code></p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if the queue is empty.</dd></dl>
<p><b>Complexity</b>: constant <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    queue.reentrant_pop();</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac83d6e59ab5dec61205db0cea6e6cf5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This is the reentrant version of try_pop. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> pop_result = queue.try_reentrant_pop();</div><div class="line">    assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    pop_result = queue.try_reentrant_pop();</div><div class="line">    assert(pop_result == <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_reentrant_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af139b5f22f2d241df4e26e8da9d95f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a reentrant consume operation. This is the reentrant version of try_start_consume.</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_1 = queue.try_start_reentrant_consume();</div><div class="line">    assert(!consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_2 = queue.try_start_reentrant_consume();</div><div class="line">    assert(consume_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab0a2b3d02d22ceb03b4bf8efdf13d47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> object. This is the reentrant version of try_start_consume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1conc__heter__queue_1_1consume__operation.html">consume_operation</a>. For an <a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a> there is no performance difference between the two overloads. Anyway for lock-free concurrent queue this overload may be faster.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    conc_heter_queue&lt;&gt;::reentrant_consume_operation consume_1;</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_reentrant_consume(consume_1);</div><div class="line">    assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    conc_heter_queue&lt;&gt;::reentrant_consume_operation consume_2;</div><div class="line">    <span class="keyword">auto</span> bool_2 = queue.try_start_reentrant_consume(consume_2);</div><div class="line">    assert(consume_2 &amp;&amp; bool_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="abb8fbaa4b1d68aaea3b603a10e39836e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1conc__heter__queue.html">conc_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two queues.</p>
<div class="fragment"><div class="line">    conc_heter_queue&lt;&gt; queue, queue_1;</div><div class="line">    queue.push(1);</div><div class="line">    <a class="code" href="classdensity_1_1conc__heter__queue.html#abb8fbaa4b1d68aaea3b603a10e39836e">swap</a>(queue, queue_1);</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line">    assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a58697d487018a8bde47d4c274c7bd76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_puts = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do put operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a2e2bd4f332d922d3024a4bb65f9d17e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_consumes = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do consume operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a30744c14b0233cd7f55466ff04151aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_put_consumes = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether puts and consumes can be done concurrently without any further synchronization. In any case unsynchronized concurrency is constrained by concurrent_puts and concurrent_consumes. </p>

</div>
</div>
<a class="anchor" id="a7708a88b67261ef454d875047bcfa79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool is_seq_cst = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this queue is sequential consistent. </p>

</div>
</div>
<a class="anchor" id="a2cdcdcfbd2342ad05b1c907bfaf76703"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t min_alignment = InnerQueue::min_alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum guaranteed alignment for every element. The actual alignment of an element may be stricter if the type requires it. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="conc__heter__queue_8h_source.html">conc_heter_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
