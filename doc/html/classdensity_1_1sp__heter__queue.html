<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: sp_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdensity_1_1sp__heter__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sp_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sp__heter__queue_8h_source.html">sp_heter_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa751aeee567f3a896028bc26f5737372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa751aeee567f3a896028bc26f5737372"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>common_type</b> = COMMON_TYPE</td></tr>
<tr class="separator:aa751aeee567f3a896028bc26f5737372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b50f4f25fd3da4205169b7280303e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad98b50f4f25fd3da4205169b7280303e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_type</b> = RUNTIME_TYPE</td></tr>
<tr class="separator:ad98b50f4f25fd3da4205169b7280303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9253fca0e3b116143a118d211fb39002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9253fca0e3b116143a118d211fb39002"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt; const runtime_type &amp;, common_type *const  &gt;</td></tr>
<tr class="separator:a9253fca0e3b116143a118d211fb39002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bafeb4e974cce856d533d2bb3de432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8bafeb4e974cce856d533d2bb3de432"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = ALLOCATOR_TYPE</td></tr>
<tr class="separator:ad8bafeb4e974cce856d533d2bb3de432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc03915d7633dfe3c2b7a160f410549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc03915d7633dfe3c2b7a160f410549"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:a6fc03915d7633dfe3c2b7a160f410549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce9d8c8e35f6c6ffb564c2e733ea05e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const value_type *</td></tr>
<tr class="separator:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22bd40cacb993e9bf49cf10e7ef245a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type</td></tr>
<tr class="separator:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1137da269e66589b98fce3416d40502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1137da269e66589b98fce3416d40502"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:ab1137da269e66589b98fce3416d40502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ce1af42d538f410180c265518d4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af38ce1af42d538f410180c265518d4f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:af38ce1af42d538f410180c265518d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace405568d0b2f3fad4990044252c7732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace405568d0b2f3fad4990044252c7732"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="separator:ace405568d0b2f3fad4990044252c7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9aca2ec3221705407ae8b1dcc9ceb555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a> () noexcept=default</td></tr>
<tr class="separator:a9aca2ec3221705407ae8b1dcc9ceb555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f6ab6debb68097a08b803f6f3f0be4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a09f6ab6debb68097a08b803f6f3f0be4">sp_heter_queue</a> (const ALLOCATOR_TYPE &amp;i_source_allocator) noexcept(std::is_nothrow_copy_constructible&lt; ALLOCATOR_TYPE &gt;::value)</td></tr>
<tr class="separator:a09f6ab6debb68097a08b803f6f3f0be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7880a499a9bb5066135e9fa653e9b147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a7880a499a9bb5066135e9fa653e9b147">sp_heter_queue</a> (ALLOCATOR_TYPE &amp;&amp;i_source_allocator) noexcept</td></tr>
<tr class="separator:a7880a499a9bb5066135e9fa653e9b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3848dcc18d5d1ccae532f655c5b8f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ab3848dcc18d5d1ccae532f655c5b8f23">sp_heter_queue</a> (<a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &amp;&amp;i_source) noexcept=default</td></tr>
<tr class="separator:ab3848dcc18d5d1ccae532f655c5b8f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec9a568a57d4c49036876fefc208aae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a6ec9a568a57d4c49036876fefc208aae">operator=</a> (<a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:a6ec9a568a57d4c49036876fefc208aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ac29f19b7f4021ce4a40e84ab895ab453">get_allocator</a> () noexcept(std::is_nothrow_copy_constructible&lt; allocator_type &gt;::value)</td></tr>
<tr class="separator:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6418bf0426ef570443a93d4456fa523"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ab6418bf0426ef570443a93d4456fa523">get_allocator_ref</a> () noexcept</td></tr>
<tr class="separator:ab6418bf0426ef570443a93d4456fa523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memItemLeft" align="right" valign="top">const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a15eaf0df4f1d8976f3e799f796dc6f7c">get_allocator_ref</a> () const  noexcept</td></tr>
<tr class="separator:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93033bab5f93975dcb9cda6b6f27a58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#aa93033bab5f93975dcb9cda6b6f27a58">~sp_heter_queue</a> ()</td></tr>
<tr class="separator:aa93033bab5f93975dcb9cda6b6f27a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863df8ed6316860117a6bf26e131bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ab863df8ed6316860117a6bf26e131bbd">empty</a> () const  noexcept</td></tr>
<tr class="separator:ab863df8ed6316860117a6bf26e131bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bfacfaaba9195e4498375659f43531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a03bfacfaaba9195e4498375659f43531">clear</a> () noexcept</td></tr>
<tr class="separator:a03bfacfaaba9195e4498375659f43531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94888fab06d0078cd93ac1562fcce9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a94888fab06d0078cd93ac1562fcce9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867536308877c33bfb29f5ca8c9ebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a52867536308877c33bfb29f5ca8c9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da90ba09177e403d9bd6f466d332eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a8da90ba09177e403d9bd6f466d332eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a857a56adb973d294e1cf85acca8efbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a722ecea4d64dc7853d3825f24f316b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65085a9e9c299f23ad95b297752d3775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a65085a9e9c299f23ad95b297752d3775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">start_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194977988482bd3bcfeb92c14ccef60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">start_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a194977988482bd3bcfeb92c14ccef60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6e2b2e2468e9ae74ce6f8bf7a36c7a"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:acb6e2b2e2468e9ae74ce6f8bf7a36c7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#acb6e2b2e2468e9ae74ce6f8bf7a36c7a">try_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a73d91b3c8a46600b1c074f39298926c8">try_emplace</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;(i_progress_guarantee, std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:acb6e2b2e2468e9ae74ce6f8bf7a36c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d91b3c8a46600b1c074f39298926c8"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a73d91b3c8a46600b1c074f39298926c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a73d91b3c8a46600b1c074f39298926c8">try_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a5b7ab6f3464f6e7130f6001631d1ce69">try_start_emplace</a>&lt; ELEMENT_TYPE &gt;(i_progress_guarantee,                                                                       std::forward&lt; CONSTRUCTION_PARAMS &gt;(i_construction_params)...)))</td></tr>
<tr class="separator:a73d91b3c8a46600b1c074f39298926c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba90ba7bf6675fda5efc5a583c771862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#aba90ba7bf6675fda5efc5a583c771862">try_dyn_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type)</td></tr>
<tr class="separator:aba90ba7bf6675fda5efc5a583c771862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379cd9d8dd9854c7e68d922e6b29d709"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a379cd9d8dd9854c7e68d922e6b29d709">try_dyn_push_copy</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a379cd9d8dd9854c7e68d922e6b29d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65e0324b3d65041543d678192a72c77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ac65e0324b3d65041543d678192a72c77">try_dyn_push_move</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:ac65e0324b3d65041543d678192a72c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc1b5938d11dc22527c4b2f10d037c"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a2dbc1b5938d11dc22527c4b2f10d037c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a2dbc1b5938d11dc22527c4b2f10d037c">try_start_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a5b7ab6f3464f6e7130f6001631d1ce69">try_start_emplace</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;(i_progress_guarantee, std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:a2dbc1b5938d11dc22527c4b2f10d037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7ab6f3464f6e7130f6001631d1ce69"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a5b7ab6f3464f6e7130f6001631d1ce69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a5b7ab6f3464f6e7130f6001631d1ce69">try_start_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(ELEMENT_TYPE(std::forward&lt; CONSTRUCTION_PARAMS &gt;(i_construction_params)...))&amp;&amp;                                                                       noexcept(runtime_type(runtime_type::template make&lt; ELEMENT_TYPE &gt;())))</td></tr>
<tr class="separator:a5b7ab6f3464f6e7130f6001631d1ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf210c72514f4af64890e81f8744fd1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#acf210c72514f4af64890e81f8744fd1c">try_start_dyn_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type)</td></tr>
<tr class="separator:acf210c72514f4af64890e81f8744fd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae1bd81baeb079bd72c8ef4acef756d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a8ae1bd81baeb079bd72c8ef4acef756d">try_start_dyn_push_copy</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a8ae1bd81baeb079bd72c8ef4acef756d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e89dc4eec811ac66fa02b59b640088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a33e89dc4eec811ac66fa02b59b640088">try_start_dyn_push_move</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a33e89dc4eec811ac66fa02b59b640088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a35b9c85fad7f5d27b7555c29b2e4e3fe">try_pop</a> () noexcept</td></tr>
<tr class="separator:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1ab782b6edf567268eee5613c82d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume</a> () noexcept</td></tr>
<tr class="separator:ac6f1ab782b6edf567268eee5613c82d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b75e28b72dcb69afe98280ad561e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a616b75e28b72dcb69afe98280ad561e0">try_start_consume</a> (<a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:a616b75e28b72dcb69afe98280ad561e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#abd4493f55adeab87efb382c118066a2e">reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:abd4493f55adeab87efb382c118066a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a0faba214d7f09f7af2d8ee795490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a22a0faba214d7f09f7af2d8ee795490d">reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a22a0faba214d7f09f7af2d8ee795490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a09fc9a353af5e0de17d9cd2c74876c3f">reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a4f42d9c13317c6a1412686c42609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a711a4f42d9c13317c6a1412686c42609">reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a711a4f42d9c13317c6a1412686c42609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a43e3c73b2740ce46477422fb90d18208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a6aa035e6311be7c63c72334427572193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d63c59edac31a0d50efc67bdd9381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a298d63c59edac31a0d50efc67bdd9381">start_reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a298d63c59edac31a0d50efc67bdd9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55249c74018c4dad488fb1eebec8bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a55249c74018c4dad488fb1eebec8bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6abd47f0a85b6d2f90de584c05270c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#af6abd47f0a85b6d2f90de584c05270c0">start_reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:af6abd47f0a85b6d2f90de584c05270c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a372a70b760b13dff6280f39acd090d"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a2a372a70b760b13dff6280f39acd090d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a2a372a70b760b13dff6280f39acd090d">try_reentrant_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a3de055b0556419fc8565c22bbefc1bf3">try_reentrant_emplace</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;(i_progress_guarantee, std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:a2a372a70b760b13dff6280f39acd090d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de055b0556419fc8565c22bbefc1bf3"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a3de055b0556419fc8565c22bbefc1bf3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a3de055b0556419fc8565c22bbefc1bf3">try_reentrant_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a8b8f2329266f5c8309a802f9949949be">try_start_reentrant_emplace</a>&lt; ELEMENT_TYPE &gt;(i_progress_guarantee,                                                                       std::forward&lt; CONSTRUCTION_PARAMS &gt;(i_construction_params)...)))</td></tr>
<tr class="separator:a3de055b0556419fc8565c22bbefc1bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27757f165d35a8df3c32511f08afb793"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a27757f165d35a8df3c32511f08afb793">try_reentrant_dyn_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a27757f165d35a8df3c32511f08afb793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53bba07d8f402d4d3f7e0da639ce1a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ac53bba07d8f402d4d3f7e0da639ce1a7">try_reentrant_dyn_push_copy</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:ac53bba07d8f402d4d3f7e0da639ce1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8530330a6f4c2c645e23ff9b76dc58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a3b8530330a6f4c2c645e23ff9b76dc58">try_reentrant_dyn_push_move</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a3b8530330a6f4c2c645e23ff9b76dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e7b25fa5bd7faf27431bd4c68d87f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a4a2e7b25fa5bd7faf27431bd4c68d87f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a4a2e7b25fa5bd7faf27431bd4c68d87f">try_start_reentrant_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(std::declval&lt; <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &gt;().template <a class="el" href="classdensity_1_1sp__heter__queue.html#a8b8f2329266f5c8309a802f9949949be">try_start_reentrant_emplace</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;(i_progress_guarantee, std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:a4a2e7b25fa5bd7faf27431bd4c68d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f2329266f5c8309a802f9949949be"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a8b8f2329266f5c8309a802f9949949be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a8b8f2329266f5c8309a802f9949949be">try_start_reentrant_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(ELEMENT_TYPE(std::forward&lt; CONSTRUCTION_PARAMS &gt;(i_construction_params)...))&amp;&amp;                                                                       noexcept(runtime_type(runtime_type::template make&lt; ELEMENT_TYPE &gt;())))</td></tr>
<tr class="separator:a8b8f2329266f5c8309a802f9949949be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68a1e4a5462243f59e7cc1cc9c0601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a3a68a1e4a5462243f59e7cc1cc9c0601">try_start_reentrant_dyn_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a3a68a1e4a5462243f59e7cc1cc9c0601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727e952ac163719f7b8defe58c749e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a727e952ac163719f7b8defe58c749e07">try_start_reentrant_dyn_push_copy</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a727e952ac163719f7b8defe58c749e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406ea21b8ea331b593a12006c2a91fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ab406ea21b8ea331b593a12006c2a91fe">try_start_reentrant_dyn_push_move</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:ab406ea21b8ea331b593a12006c2a91fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#ac83d6e59ab5dec61205db0cea6e6cf5b">try_reentrant_pop</a> () noexcept</td></tr>
<tr class="separator:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume</a> () noexcept</td></tr>
<tr class="separator:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#aab0a2b3d02d22ceb03b4bf8efdf13d47">try_start_reentrant_consume</a> (<a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a2cdcdcfbd2342ad05b1c907bfaf76703">min_alignment</a> = Base::min_alignment</td></tr>
<tr class="separator:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58697d487018a8bde47d4c274c7bd76a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a58697d487018a8bde47d4c274c7bd76a">concurrent_puts</a> = PROD_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td></tr>
<tr class="separator:a58697d487018a8bde47d4c274c7bd76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a2e2bd4f332d922d3024a4bb65f9d17e4">concurrent_consumes</a> = CONSUMER_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td></tr>
<tr class="separator:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30744c14b0233cd7f55466ff04151aa9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a30744c14b0233cd7f55466ff04151aa9">concurrent_put_consumes</a> = true</td></tr>
<tr class="separator:a30744c14b0233cd7f55466ff04151aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7708a88b67261ef454d875047bcfa79d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a7708a88b67261ef454d875047bcfa79d">is_seq_cst</a> = true</td></tr>
<tr class="separator:a7708a88b67261ef454d875047bcfa79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a00edb65e6a311348e86f89bb69b80796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__heter__queue.html#a00edb65e6a311348e86f89bb69b80796">swap</a> (<a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &amp;i_first, <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> &amp;i_second) noexcept</td></tr>
<tr class="separator:a00edb65e6a311348e86f89bb69b80796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename COMMON_TYPE = void, typename RUNTIME_TYPE = runtime_type&lt;COMMON_TYPE&gt;, typename ALLOCATOR_TYPE = void_allocator, concurrency_cardinality PROD_CARDINALITY = concurrency_multiple, concurrency_cardinality CONSUMER_CARDINALITY = concurrency_multiple, typename BUSY_WAIT_FUNC = default_busy_wait&gt;<br />
class density::sp_heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt;</h3>

<p>Concurrent heterogeneous FIFO container-like class template. <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> is a concurrent version of <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> that uses a mix of lock free algorithms and spin locking. This class is very similar to <a class="el" href="classdensity_1_1lf__heter__queue.html">lf_heter_queue</a>, with the difference that if multiple producers are supported, they use a spin-locking mutex to synchronize the write to the tail pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMMON_TYPE</td><td>Common type of all the elements. An object of type E can be pushed on the queue only if E* is implicitly convertible to COMMON_TYPE*. If COMMON_TYPE is void (the default), any type can be put in the queue. Otherwise it should be an user-defined-type, and only types deriving from it can be added. </td></tr>
    <tr><td class="paramname">RUNTIME_TYPE</td><td>Runtime-type object used to handle the actual complete type of each element. This type must meet the requirements of <a class="el" href="RuntimeType_concept.html">RuntimeType</a>. The default is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. </td></tr>
    <tr><td class="paramname">ALLOCATOR_TYPE</td><td>Allocator type to be used. This type must meet the requirements of both <a class="el" href="UntypedAllocator_concept.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_concept.html">PagedAllocator</a>. The default is <a class="el" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">density::void_allocator</a>. </td></tr>
    <tr><td class="paramname">PROD_CARDINALITY</td><td>specifies whether multiple threads can do put transactions concurrently. Must be a member of <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cb">density::concurrency_cardinality</a>. </td></tr>
    <tr><td class="paramname">CONSUMER_CARDINALITY</td><td>specifies whether multiple threads can do consume operations concurrently. Must be a member of <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cb">density::concurrency_cardinality</a>. </td></tr>
    <tr><td class="paramname">BUSY_WAIT_FUNC</td><td>callable object to be invoked (with an empty parameter list) in the body of the spin lock. The default is <a class="el" href="classdensity_1_1default__busy__wait.html">density::default_busy_wait</a>, that calls std::this_thread::yield.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Thread safeness</b>: A thread doing put operations and another thread doing consumes don't need to be synchronized. If PROD_CARDINALITY is concurrency_multiple, multiple threads are allowed to put without any synchronization. If CONSUMER_CARDINALITY is concurrency_multiple, multiple threads are allowed to consume without any synchronization. <br />
 <b>Exception safeness</b>: Any function of <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> is noexcept or provides the strong exception guarantee.</p>
<p>The default allocator, void_allocator, delegates legacy memory operations to the system. Since the storage elements whose size exceeds a fixed limit can't be allocated in a page, they require a legacy memory allocation, and in this case the put can't be lock-free.</p>
<p>This class template provides all the put functions provided by <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>, and furthermore it adds the try_ variants, that:</p><ul>
<li>Don't throw in case of failure allocating memory. Anyway they pass through any exception thrown by the constructor of the element and the constructor of the runtime type.</li>
<li>Allow to specify a progress guarantee to be respected by the overall operation. For example, if the lock-free guarantee is requested, but it requires a memory operation that the allocator is not able to complete in lock-freedom, the put fails. In the current implementation, wait-free put operation may fail even in isolation, because page pinning is lock-free but not wait-free.</li>
</ul>
<p>Also raw allocation functions have the try_ versions. They do not throw in case of failure, but just return null.</p>
<p>This table shows all the put functions supported by <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>:</p>
<a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Put functions</caption>
<tr>
<th style="width:150px">Group </th><th style="width:100px">Normal </th><th style="width:100px">Transactional </th><th style="width:100px">Reentrant </th><th style="width:100px">Transactional-Reentrant </th><th style="width:130px">Type binding </th><th style="width:130px">Constructor  </th></tr>
<tr>
<td>push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#abd4493f55adeab87efb382c118066a2e">reentrant_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Copy/Move  </td></tr>
<tr>
<td>emplace </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Any  </td></tr>
<tr>
<td>dynamic push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a22a0faba214d7f09f7af2d8ee795490d">reentrant_dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a298d63c59edac31a0d50efc67bdd9381">start_reentrant_dyn_push</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Default  </td></tr>
<tr>
<td>dynamic push (copy) </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">start_dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a09fc9a353af5e0de17d9cd2c74876c3f">reentrant_dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Copy  </td></tr>
<tr>
<td>dynamic push (move) </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">start_dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a711a4f42d9c13317c6a1412686c42609">reentrant_dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#af6abd47f0a85b6d2f90de584c05270c0">start_reentrant_dyn_push_move</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Move  </td></tr>
<tr>
<td>try push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#acb6e2b2e2468e9ae74ce6f8bf7a36c7a">try_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a2dbc1b5938d11dc22527c4b2f10d037c">try_start_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a2a372a70b760b13dff6280f39acd090d">try_reentrant_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a4a2e7b25fa5bd7faf27431bd4c68d87f">try_start_reentrant_push</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Copy/Move  </td></tr>
<tr>
<td>try emplace </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a73d91b3c8a46600b1c074f39298926c8">try_emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a5b7ab6f3464f6e7130f6001631d1ce69">try_start_emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a3de055b0556419fc8565c22bbefc1bf3">try_reentrant_emplace</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a8b8f2329266f5c8309a802f9949949be">try_start_reentrant_emplace</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Any  </td></tr>
<tr>
<td>try dynamic push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#aba90ba7bf6675fda5efc5a583c771862">try_dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#acf210c72514f4af64890e81f8744fd1c">try_start_dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a27757f165d35a8df3c32511f08afb793">try_reentrant_dyn_push</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a3a68a1e4a5462243f59e7cc1cc9c0601">try_start_reentrant_dyn_push</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Default  </td></tr>
<tr>
<td>try dynamic push (copy) </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a379cd9d8dd9854c7e68d922e6b29d709">try_dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a8ae1bd81baeb079bd72c8ef4acef756d">try_start_dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#ac53bba07d8f402d4d3f7e0da639ce1a7">try_reentrant_dyn_push_copy</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a727e952ac163719f7b8defe58c749e07">try_start_reentrant_dyn_push_copy</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Copy  </td></tr>
<tr>
<td>try dynamic push (move) </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#ac65e0324b3d65041543d678192a72c77">try_dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a33e89dc4eec811ac66fa02b59b640088">try_start_dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#a3b8530330a6f4c2c645e23ff9b76dc58">try_reentrant_dyn_push_move</a> </div></div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1sp__heter__queue.html#ab406ea21b8ea331b593a12006c2a91fe">try_start_reentrant_dyn_push_move</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Move  </td></tr>
</table>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9aca2ec3221705407ae8b1dcc9ceb555"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. The allocator is default-constructed.</p>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory and never throws.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a09f6ab6debb68097a08b803f6f3f0be4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is copy-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to copy-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: whatever the copy constructor of the allocator throws. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the copy constructor of the allocator throws.</p>
<div class="fragment"><div class="line">            void_allocator allocator;</div><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue(allocator);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7880a499a9bb5066135e9fa653e9b147"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is move-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to move-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the move constructor of the allocator throws.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            void_allocator allocator;</div><div class="line">            SpQueue queue(std::move(allocator));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab3848dcc18d5d1ccae532f655c5b8f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. The allocator is move-constructed from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
</ul>
<div class="fragment"><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">            queue.push(std::string());</div><div class="line">            queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue_1(std::move(queue));</div><div class="line"></div><div class="line">            assert(queue.empty());</div><div class="line">            assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa93033bab5f93975dcb9cda6b6f27a58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator pointing to this queue is invalidated. <br />
 <b>Throws</b>: Nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6ec9a568a57d4c49036876fefc208aae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment. The allocator is move-assigned from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: Any iterator pointing to this queue or to the source queue is invalidated. <br />
 <b>Throws</b>: Nothing.</p>
<p><br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
<li>The complexity is linear in the number of elements in this queue.</li>
</ul>
<div class="fragment"><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">using</span> SpQueue = <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            queue.push(std::string(<span class="stringliteral">&quot;abc&quot;</span>));</div><div class="line">            queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">            SpQueue queue_1;</div><div class="line">            queue_1 = std::move(queue);</div><div class="line"></div><div class="line">            assert(queue.empty());</div><div class="line"></div><div class="line">            assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac29f19b7f4021ce4a40e84ab895ab453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the allocator</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            assert(queue.get_allocator() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6418bf0426ef570443a93d4456fa523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the allocator</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            assert(queue.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15eaf0df4f1d8976f3e799f796dc6f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the allocator</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp; queue_ref = queue;</div><div class="line">            assert(queue_ref.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab863df8ed6316860117a6bf26e131bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the queue contains no elements.</p>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            assert(queue.empty());</div><div class="line">            queue.push(1);</div><div class="line">            assert(!queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03bfacfaaba9195e4498375659f43531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all the elements in the queue.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator is invalidated <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            queue.push(1);</div><div class="line">            queue.clear();</div><div class="line">            assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae79645ce0f8c0616bbfda669fa6fbadf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed</li>
<li>If this argument is an r-value, the new element move-constructed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line">            queue.push(12);</div><div class="line">            queue.push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a49d0820906b9bd4c1b5a1b08980a9330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument ELEMENT_TYPE can't be deduced from the parameters so it must explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line">            queue.template emplace&lt;int&gt;();</div><div class="line">            queue.template emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a94888fab06d0078cd93ac1562fcce9bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, default-constructing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::default_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>default_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::template make&lt;int&gt;();</div><div class="line">            queue.dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a52867536308877c33bfb29f5ca8c9ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of a type known at runtime, copy-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code>. <em>Note</em>: be careful using void pointers: only the compiler knows how to casts from/to a base to/from a derived class.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::copy_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>copy_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            queue.dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8da90ba09177e403d9bd6f466d332eca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code> <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::move_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>move_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            queue.dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857a56adb973d294e1cf85acca8efbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed.</li>
<li>If this argument is an r-value, the new element move-constructed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> put = queue.start_push(12);</div><div class="line">            put.element() += 2;</div><div class="line">            put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a722ecea4d64dc7853d3825f24f316b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;ELEMENT_TYPE&gt; start_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> put = queue.template start_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">            put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">            put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65085a9e9c299f23ad95b297752d3775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, default-constructing it. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_dyn_push(type);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aac2746c80dae973ad196b7f12c1bbcc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, copy-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_dyn_push_copy(type, &amp;source);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a194977988482bd3bcfeb92c14ccef60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, move-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_dyn_push_move(type, &amp;source);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acb6e2b2e2468e9ae74ce6f8bf7a36c7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to append at the end of the queue an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns false to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed</li>
<li>If this argument is an r-value, the new element move-constructed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the put operation was successful</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws (conditionally noexcept) <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordtype">bool</span> successful = <span class="keyword">false</span>;</div><div class="line">            <span class="keywordflow">if</span> (queue.try_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, 12))</div><div class="line">            {</div><div class="line">                successful = queue.try_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a73d91b3c8a46600b1c074f39298926c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to append at the end of the queue an element of type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns false to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 <em>Note</em>: the template argument ELEMENT_TYPE can't be deduced from the parameters so it must explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the put operation was successful</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws (conditionally noexcept) <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordtype">bool</span> successful = <span class="keyword">false</span>;</div><div class="line">            <span class="keywordflow">if</span> (queue.template try_emplace&lt;int&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>))</div><div class="line">            {</div><div class="line">                successful = queue.template try_emplace&lt;std::string&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, 12, <span class="charliteral">&#39;-&#39;</span>);</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aba90ba7bf6675fda5efc5a583c771862"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_dyn_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue an element of a type known at runtime, default-constructing it. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns false to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the put operation was successful</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::default_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>default_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_dyn_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type)) <span class="comment">// appends 0</span></div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a379cd9d8dd9854c7e68d922e6b29d709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue an element of a type known at runtime, copy-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns false to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code>. <em>Note</em>: be careful using void pointers: only the compiler knows how to casts from/to a base to/from a derived class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the put operation was successful</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::copy_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>copy_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_dyn_push_copy(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac65e0324b3d65041543d678192a72c77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries add at the end of the queue an element of a type known at runtime, move-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns false to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code> <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the put operation was successful</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::move_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>move_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_dyn_push_move(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2dbc1b5938d11dc22527c4b2f10d037c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; try_start_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns an empty transaction to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed.</li>
<li>If this argument is an r-value, the new element move-constructed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws (conditionally noexcept) <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, 12))</div><div class="line">            {</div><div class="line">                <span class="comment">// ..</span></div><div class="line">                put.element() += 2;</div><div class="line">                put.commit(); <span class="comment">// commits a 14</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b7ab6f3464f6e7130f6001631d1ce69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a>&lt;ELEMENT_TYPE&gt; try_start_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns an empty transaction to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and of the runtime type throws (conditionally noexcept) <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.template try_start_emplace&lt;std::string&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, 4, <span class="charliteral">&#39;*&#39;</span>))</div><div class="line">            {</div><div class="line">                <span class="comment">// ..</span></div><div class="line">                put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">                put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acf210c72514f4af64890e81f8744fd1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> try_start_dyn_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of a type known at runtime, default-constructing it. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns an empty transaction to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_dyn_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type))</div><div class="line">            {</div><div class="line">                <span class="comment">// ....</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8ae1bd81baeb079bd72c8ef4acef756d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> try_start_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of a type known at runtime, copy-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns an empty transaction to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_dyn_push_copy(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a33e89dc4eec811ac66fa02b59b640088"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">put_transaction</a> try_start_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of a type known at runtime, move-constructing it from the source. <br />
 If the put operation can't be completed with the specified progress guarantee, this function returns an empty transaction to indicate a failure, and has no observable effects. This function fails if:</p><ul>
<li>a memory allocation is necessary but the allocator can't complete it with the specified progress guarantee. A failure with the blocking progress guarantee indicates an out of memory, but no exception is thrown.</li>
<li>there is a contention between threads, and the wait-free progress guarantee is requested</li>
<li>the algorithm would perform some non wait-free operations (like page pinning), and the wait-free progress guarantee is requested</li>
</ul>
<p><br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan by the same thread, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>progress guarantee to respect </td></tr>
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: what the construction of the element and the runtime type throws <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a9aca2ec3221705407ae8b1dcc9ceb555">sp_heter_queue</a>&lt;void, MyRunTimeType, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_dyn_push_move(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9ac62e490a69e1757bd357e6e4e3cf1f3d">progress_wait_free</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ..</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a35b9c85fad7f5d27b7555c29b2e4e3fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> pop_result = queue.try_pop();</div><div class="line">            assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">            queue.push(1);</div><div class="line">            queue.push(2);</div><div class="line"></div><div class="line">            pop_result = queue.try_pop();</div><div class="line">            assert(pop_result == <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">            assert(consume.template element&lt;int&gt;() == 2);</div><div class="line">            consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6f1ab782b6edf567268eee5613c82d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> try_start_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> consume_1 = queue.try_start_consume();</div><div class="line">            assert(!consume_1);</div><div class="line"></div><div class="line">            queue.push(42);</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> consume_2 = queue.try_start_consume();</div><div class="line">            assert(consume_2);</div><div class="line">            assert(consume_2.template element&lt;int&gt;() == 42);</div><div class="line">            consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a616b75e28b72dcb69afe98280ad561e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a>, but it's more efficient if the next consumable element is in the same page of the last element i_consume has visited because in this case it doesn't perform page pinning.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line"></div><div class="line">            <span class="keyword">typename</span> SpQueue::consume_operation consume_1;</div><div class="line">            <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_consume(consume_1);</div><div class="line">            assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">            queue.push(42);</div><div class="line"></div><div class="line">            <span class="keyword">typename</span> SpQueue::consume_operation consume_2;</div><div class="line">            <span class="keyword">auto</span> bool_2 = queue.try_start_consume(consume_2);</div><div class="line">            assert(consume_2 &amp;&amp; bool_2);</div><div class="line">            assert(consume_2.template element&lt;int&gt;() == 42);</div><div class="line">            consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd4493f55adeab87efb382c118066a2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">sp_heter_queue::push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            queue.reentrant_push(12);</div><div class="line">            queue.reentrant_push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99a0cef94c1cde53cf68ce8c11bbc74f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">sp_heter_queue::emplace</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            queue.template reentrant_emplace&lt;int&gt;();</div><div class="line">            queue.template reentrant_emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a22a0faba214d7f09f7af2d8ee795490d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">sp_heter_queue::dyn_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            queue.reentrant_dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a09fc9a353af5e0de17d9cd2c74876c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">sp_heter_queue::dyn_push_copy</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            queue.reentrant_dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a711a4f42d9c13317c6a1412686c42609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">sp_heter_queue::dyn_push_move</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            queue.reentrant_dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a43e3c73b2740ce46477422fb90d18208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">sp_heter_queue::start_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> put = queue.start_reentrant_push(12);</div><div class="line">            put.element() += 2;</div><div class="line">            put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6aa035e6311be7c63c72334427572193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">sp_heter_queue::start_emplace</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue;</div><div class="line">            <span class="keyword">auto</span> put = queue.template start_reentrant_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">            put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">            put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a298d63c59edac31a0d50efc67bdd9381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a65085a9e9c299f23ad95b297752d3775">sp_heter_queue::start_dyn_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push(type);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a55249c74018c4dad488fb1eebec8bde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">sp_heter_queue::start_dyn_push_copy</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_copy(type, &amp;source);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6abd47f0a85b6d2f90de584c05270c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">sp_heter_queue::start_dyn_push_move</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_move(type, &amp;source);</div><div class="line">            put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a372a70b760b13dff6280f39acd090d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#acb6e2b2e2468e9ae74ce6f8bf7a36c7a">sp_heter_queue::try_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (queue.try_reentrant_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, 12))</div><div class="line">            {</div><div class="line">                <span class="keywordflow">if</span> (queue.try_reentrant_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>)))</div><div class="line">                {</div><div class="line">                    <span class="comment">// ...</span></div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3de055b0556419fc8565c22bbefc1bf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a73d91b3c8a46600b1c074f39298926c8">sp_heter_queue::try_emplace</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.template try_start_reentrant_emplace&lt;std::string&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, 4, <span class="charliteral">&#39;*&#39;</span>))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">                put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27757f165d35a8df3c32511f08afb793"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#aba90ba7bf6675fda5efc5a583c771862">sp_heter_queue::try_dyn_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_reentrant_dyn_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type)) <span class="comment">// appends 0</span></div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac53bba07d8f402d4d3f7e0da639ce1a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a379cd9d8dd9854c7e68d922e6b29d709">sp_heter_queue::try_dyn_push_copy</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_reentrant_dyn_push_copy(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3b8530330a6f4c2c645e23ff9b76dc58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#ac65e0324b3d65041543d678192a72c77">sp_heter_queue::try_dyn_push_move</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (queue.try_reentrant_dyn_push_move(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4a2e7b25fa5bd7faf27431bd4c68d87f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; try_start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a2dbc1b5938d11dc22527c4b2f10d037c">sp_heter_queue::try_start_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_reentrant_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, 12))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.element() += 2;</div><div class="line">                put.commit(); <span class="comment">// commits a 14</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8b8f2329266f5c8309a802f9949949be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; try_start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a5b7ab6f3464f6e7130f6001631d1ce69">sp_heter_queue::try_start_emplace</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.template try_start_reentrant_emplace&lt;std::string&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, 4, <span class="charliteral">&#39;*&#39;</span>))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">                put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3a68a1e4a5462243f59e7cc1cc9c0601"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> try_start_reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#acf210c72514f4af64890e81f8744fd1c">sp_heter_queue::try_start_dyn_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_reentrant_dyn_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a727e952ac163719f7b8defe58c749e07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> try_start_reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a8ae1bd81baeb079bd72c8ef4acef756d">sp_heter_queue::try_start_dyn_push_copy</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_reentrant_dyn_push_copy(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab406ea21b8ea331b593a12006c2a91fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> try_start_reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1sp__heter__queue.html#a33e89dc4eec811ac66fa02b59b640088">sp_heter_queue::try_start_dyn_push_move</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">            <span class="keyword">using namespace </span><a class="code" href="namespacedensity_1_1type__features.html">density::type_features</a>;</div><div class="line">            <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">            sp_heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">            std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">            <span class="keywordflow">if</span> (<span class="keyword">auto</span> put = queue.try_start_reentrant_dyn_push_move(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a0b054ba80f8a8881937f74469fb43e79">progress_blocking</a>, type, &amp;source))</div><div class="line">            {</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                put.commit();</div><div class="line">            }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac83d6e59ab5dec61205db0cea6e6cf5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This is the reentrant version of try_pop. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line"></div><div class="line">            <span class="keywordtype">bool</span> pop_result = queue.try_reentrant_pop();</div><div class="line">            assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">            queue.push(1);</div><div class="line">            queue.push(2);</div><div class="line"></div><div class="line">            pop_result = queue.try_reentrant_pop();</div><div class="line">            assert(pop_result == <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">auto</span> consume = queue.try_start_reentrant_consume();</div><div class="line">            assert(consume.template element&lt;int&gt;() == 2);</div><div class="line">            consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af139b5f22f2d241df4e26e8da9d95f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a reentrant consume operation. This is the reentrant version of try_start_consume.</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> consume_1 = queue.try_start_reentrant_consume();</div><div class="line">            assert(!consume_1);</div><div class="line"></div><div class="line">            queue.push(42);</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> consume_2 = queue.try_start_reentrant_consume();</div><div class="line">            assert(consume_2);</div><div class="line">            assert(consume_2.template element&lt;int&gt;() == 42);</div><div class="line">            consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab0a2b3d02d22ceb03b4bf8efdf13d47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> object. This is the reentrant version of try_start_consume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1sp__heter__queue_1_1consume__operation.html">consume_operation</a>. For an <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> there is no performance difference between the two overloads. Anyway for lock-free concurrent queue this overload may be faster.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line">            SpQueue queue;</div><div class="line"></div><div class="line">            <span class="keyword">typename</span> SpQueue::reentrant_consume_operation consume_1;</div><div class="line">            <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_reentrant_consume(consume_1);</div><div class="line">            assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">            queue.push(42);</div><div class="line"></div><div class="line">            <span class="keyword">typename</span> SpQueue::reentrant_consume_operation consume_2;</div><div class="line">            <span class="keyword">auto</span> bool_2 = queue.try_start_reentrant_consume(consume_2);</div><div class="line">            assert(consume_2 &amp;&amp; bool_2);</div><div class="line">            assert(consume_2.template element&lt;int&gt;() == 42);</div><div class="line">            consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a00edb65e6a311348e86f89bb69b80796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two queues.</p>
<div class="fragment"><div class="line">            <span class="keyword">using</span> SpQueue = sp_heter_queue&lt;void, runtime_type&lt;&gt;, <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>,</div><div class="line">                PROD_CARDINALITY, CONSUMER_CARDINALITY&gt;;</div><div class="line"></div><div class="line">            SpQueue queue, queue_1;</div><div class="line">            queue.push(1);</div><div class="line">            <a class="code" href="classdensity_1_1sp__heter__queue.html#a00edb65e6a311348e86f89bb69b80796">swap</a>(queue, queue_1);</div><div class="line"></div><div class="line">            assert(queue.empty());</div><div class="line">            assert(!queue_1.empty());</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2cdcdcfbd2342ad05b1c907bfaf76703"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t min_alignment = Base::min_alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum alignment used for the storage of the elements. The storage of elements is always aligned according to the most-derived type. </p>

</div>
</div>
<a class="anchor" id="a58697d487018a8bde47d4c274c7bd76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_puts = PROD_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do put operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a2e2bd4f332d922d3024a4bb65f9d17e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_consumes = CONSUMER_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do consume operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a30744c14b0233cd7f55466ff04151aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_put_consumes = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether puts and consumes can be done concurrently without any further synchronization. In any case unsynchronized concurrency is constrained by concurrent_puts and concurrent_consumes. </p>

</div>
</div>
<a class="anchor" id="a7708a88b67261ef454d875047bcfa79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool is_seq_cst = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this queue is sequential consistent. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="sp__heter__queue_8h_source.html">sp_heter_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
