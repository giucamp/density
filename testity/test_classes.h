
//   Copyright Giuseppe Campana (giu.campana@gmail.com) 2016.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#pragma once
#include <string>
#include <chrono>
#include <stdint.h>
#include <random>
#include "testity_common.h"

namespace testity
{
    enum class FeatureKind
    {
        Deleted,
        Supported,
        SupportedNoExcept
    };

    namespace detail
    {
        void random_storage_init(unsigned char * i_dest, size_t i_size) noexcept;
        void random_storage_init(unsigned char * i_dest, size_t i_size, int i_seed) noexcept;
        void random_storage_mark_moved_from(unsigned char * i_dest, size_t i_size) noexcept;
        void random_storage_mark_deleted(unsigned char * i_dest, size_t i_size) noexcept;
        bool random_storage_equals(const unsigned char * i_first, const unsigned char * i_second, size_t i_size) noexcept;
        size_t random_storage_hash(const unsigned char * i_dest, size_t i_size) noexcept;

        template <size_t SIZE>
            struct RandomStorage
        {
        public:

            RandomStorage() noexcept
            {
                random_storage_init(m_data, SIZE);
            }

            RandomStorage(int i_seed) noexcept
            {
                random_storage_init(m_data, SIZE, i_seed);
            }

            RandomStorage(const RandomStorage &) noexcept = default;
            RandomStorage & operator = (const RandomStorage &) noexcept = default;

            RandomStorage(RandomStorage && i_source) noexcept
                : RandomStorage(i_source) // call the copy constructor
            {
                random_storage_mark_moved_from(i_source.m_data, SIZE);
            }

            RandomStorage & operator = (RandomStorage &&) noexcept
            {
                *this = i_source; // call the copy assignment
                random_storage_mark_moved_from(i_source.m_data, SIZE);
            }

            bool operator == (const RandomStorage & i_other) const
            {
                return random_storage_equals(m_data, i_other.m_data, SIZE);
            }

            bool operator != (const RandomStorage & i_other) const
            {
                return !random_storage_equals(m_data, i_other.m_data, SIZE);
            }

            ~RandomStorage()
            {
                random_storage_mark_deleted(m_data, SIZE);
            }

            size_t hash() const noexcept
            {
                return random_storage_hash(m_data, SIZE);
            }

        private:
            unsigned char m_data[SIZE];
        };
    }

    template <
        FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT,
        FeatureKind COPY_SUPPORT,
        FeatureKind MOVE_SUPPORT,
        size_t SIZE = alignof(std::max_align_t),
        size_t ALIGNMENT = alignof(std::max_align_t) >
            class TestClass;

    // warning: the following 27 partial specialization were generated by the program TestClassGen

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Deleted, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() = delete;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::Supported, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() { exception_check_point(); }

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Deleted, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) = delete;
        TestClass & operator = (const TestClass &) = delete;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::Supported, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass & i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), i_source)) { }
        const TestClass & operator = (const TestClass & i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (i_source); return *this; }

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Deleted, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) = delete;
        TestClass & operator = (TestClass &&) = delete;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::Supported, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass && i_source)
            : detail::RandomStorage<SIZE>((exception_check_point(), std::move(i_source))) { exception_check_point(); }
        const TestClass & operator = (TestClass && i_source)
            { exception_check_point(); detail::RandomStorage<SIZE>::operator = (std::move(i_source)); return *this; }

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    template <size_t SIZE, size_t ALIGNMENT>
        class alignas(ALIGNMENT) TestClass<FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, FeatureKind::SupportedNoExcept, SIZE, ALIGNMENT> : public detail::RandomStorage<SIZE>
    {
    public:
        // default constructor
        TestClass() noexcept = default;

        // constructor with int seed
        TestClass(int i_seed) : detail::RandomStorage<SIZE>((exception_check_point(), i_seed)) { }

        // copy
        TestClass(const TestClass &) noexcept = default;
        TestClass & operator = (const TestClass &) noexcept = default;

        // move
        TestClass(TestClass &&) noexcept = default;
        TestClass & operator = (TestClass &&) noexcept = default;

        // comparison
        bool operator == (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator == (i_other); }
        bool operator != (const TestClass & i_other) const
            { return detail::RandomStorage<SIZE>::operator != (i_other); }
    };

    // warning: the above 27 partial specialization were generated by the program TestClassGen - END

    using UnmovableTestClass = TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Deleted, 32>;
    using UniqueTestClass = TestClass<FeatureKind::Supported, FeatureKind::Deleted, FeatureKind::Supported, 32>;
    using CopyableTestClass = TestClass<FeatureKind::Supported, FeatureKind::Supported, FeatureKind::Supported, 32>;

    template < FeatureKind DEFAULT_CONSTRUCTOR_SUPPORT, FeatureKind COPY_SUPPORT, FeatureKind MOVE_SUPPORT, size_t SIZE = alignof(std::max_align_t), size_t ALIGNMENT = alignof(std::max_align_t) >
        inline size_t hash_func(const TestClass<DEFAULT_CONSTRUCTOR_SUPPORT, COPY_SUPPORT, MOVE_SUPPORT, SIZE, ALIGNMENT> & i_object) noexcept
    {
        return i_object.hash();
    }
}
